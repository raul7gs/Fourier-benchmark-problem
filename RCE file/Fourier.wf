{
  "identifier" : "caf445f3-67a2-4ad5-810c-7f80080bfcaf",
  "workflowVersion" : "5",
  "name" : "Fourier.wf",
  "nodes" : [ {
    "identifier" : "217b6ae0-de43-458e-a356-883a583118e9",
    "name" : "C_concurrency_resolution_BA855eeB",
    "location" : "1650:740",
    "zIndex" : "26",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "a483327b-86dd-4aee-80d9-b9dab51623ba",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "935d8c06-7261-4bff-a7ba-5689e3628f37",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "8c015486-0046-4d4b-a5f6-a05949935f8b",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "513fec3e-5bdf-4cb7-aff4-c908908ed612",
    "name" : "C_concurrency_resolution_BA855eeB_merger",
    "location" : "1670:670",
    "zIndex" : "27",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/y/output_y\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/y/output_y\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "eaa9ff16-ae3f-45e8-a484-7ba45b3a548e",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "7bd82625-8d09-4909-a0bf-19dbfb064f84",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "051e6c85-13f2-483d-99f9-fe1fd77d09d6",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "09d714a2-1787-4c5a-8e58-c079d411300e",
    "name" : "C_fourier",
    "location" : "1535:1180",
    "zIndex" : "37",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.C_fourier",
      "version" : "1.0",
      "name" : "C_fourier"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "2ee995ee-5b84-4247-a173-22888e84911f",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "9daaf3fc-a6e9-4d06-8b87-72c9712b28ca",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "fdcbcb1f-b399-44e5-b894-be796eb0dc70",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8",
    "name" : "C_global_to_local",
    "location" : "1650:1080",
    "zIndex" : "25",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nNone\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n\n\n    dictionary = deactivation_logic\n    root_removal = False    # In case a direct child of the root is deleted, it is needed to reformat the last line of the xml\n    for i_con in range(len(dictionary['Xpath'])):\n        xpath = dictionary['Xpath'][i_con]\n        architectural_decision = dictionary['Architectural_decision'][i_con]\n        if architectural_decision.do_assert(architecture_file):    # It means the variable has to be disactivated\n            xpath_no_root = xpath.split('/', 2)[2]\n            try:    # Delete process is different depending if the delete takes place in a direct child of the root or not\n                parent = xpath_no_root.rsplit(\"/\", 1)[0]\n                child = xpath_no_root.rsplit(\"/\", 1)[1]\n                for possible_parent in root.findall(parent):\n                    children = possible_parent.findall(child)\n                    for possible_child in children:\n                        possible_parent.remove(possible_child)\n                    possible_parent.text = possible_parent.text[:-1]\n            except:\n                parent = xpath_no_root\n                for possible_parent in root.findall(parent):\n                    root.remove(possible_parent)\n                root_removal = True\n\n\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = None\ndeactivation_logic = {'Xpath': ['/disciplines/y/c', '/disciplines/z/c'], 'Architectural_decision': [ElStrEq('/disciplines/Architecture/Input', 'z'), ElStrEq('/disciplines/Architecture/Input', 'y')]}\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "5811ff0d-ba71-4532-82d0-d76890706e69",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "8e196d40-2760-46dc-bd9a-4a4ec38fe4f4",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "0f81b1ae-fb66-475c-bc92-01aeaa55a2a5",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "53b1231b-b3f8-4ca4-9769-dd64d0ff8de8",
    "name" : "C_input_filter",
    "location" : "1555:1100",
    "zIndex" : "22",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/z/c\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/z/c\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "85c97adf-4b82-4f1c-8a8e-1c832121503d",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "b5a58f64-0fa5-400a-ab95-e7fb3c074d61",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "87cd1d40-9cb3-4c96-a98b-091daad7dd43",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "231202f3-ca0d-47a3-bf29-901d9740feb6",
    "name" : "C_merge_script",
    "location" : "1720:1170",
    "zIndex" : "24",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "e6fe65aa-d167-4e0a-b849-4851ac14611c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "67d3853e-3590-43a2-b968-93d2c37bc141",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "61d7b054-aa6a-4db6-aab1-b4ea3375bdef",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c9c1ca53-f895-46c5-b394-35f22cc12ef2",
    "name" : "C_output_filter",
    "location" : "1645:1190",
    "zIndex" : "23",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/C\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/C\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "2c24a3cb-6100-4b32-bf2c-25fe8a5ebcbe",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "466b7fe9-9bd2-4a18-9e89-9d62fc35a4c1",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "a038d161-3d40-4bc8-8f75-9e6154cb038c",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "04400b23-bd4e-470e-95a1-f8e9d687e31e",
    "name" : "Input_Provider",
    "location" : "81:-28",
    "zIndex" : "32",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.inputprovider",
      "version" : "3.2",
      "name" : "Input Provider"
    },
    "configuration" : {
      "storeComponentHistoryData" : "true"
    },
    "dynamicOutputs" : [ {
      "identifier" : "03ce7338-43a1-43f2-9442-0589b681c41a",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "startValue" : "Fourier/General_input_rep.xml"
      }
    } ]
  }, {
    "identifier" : "5c5060fa-2a96-44df-8169-db5ab01c7b5b",
    "name" : "Obj_Fourier",
    "location" : "1935:1356",
    "zIndex" : "36",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Obj_Fourier",
      "version" : "1.0",
      "name" : "Obj_Fourier"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "ee3056d2-2bbb-4a8f-bed3-56262bb2c3ad",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "43472a82-8255-4f49-bd1a-cab546e155ad",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "522ceba9-a36e-440e-b993-61148bf5a438",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "d3d85dec-8138-45ff-bf7d-66c96333e43b",
    "name" : "Obj_Output_Writer",
    "location" : "2260:1370",
    "zIndex" : "33",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.outputwriter",
      "version" : "2.1",
      "name" : "Output Writer"
    },
    "configuration" : {
      "OWWritePath" : "${targetRootFolder}",
      "SelectRootOnWorkflowStart" : "true",
      "SelectedRoot" : "",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "bc7d72a1-8862-4fc4-91ff-c2d3e3850370",
      "name" : "XML",
      "epIdentifier" : "default",
      "group" : "write",
      "datatype" : "FileReference",
      "metadata" : {
        "filename" : "[Timestamp at workflow start]__[Workflow name]__[Execution count].xml",
        "folderForSaving" : "[root]"
      }
    } ],
    "dynamicInputGroups" : [ {
      "name" : "2bfe07e3-b97f-4fa1-9baf-a41edc1f6f8b",
      "epIdentifier" : "dynamicAndGroup"
    } ]
  }, {
    "identifier" : "c638b003-5fbd-43a3-a173-3f93765662ab",
    "name" : "Obj_global_to_local",
    "location" : "2050:1260",
    "zIndex" : "31",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nNone\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n\n\n    dictionary = deactivation_logic\n    root_removal = False    # In case a direct child of the root is deleted, it is needed to reformat the last line of the xml\n    for i_con in range(len(dictionary['Xpath'])):\n        xpath = dictionary['Xpath'][i_con]\n        architectural_decision = dictionary['Architectural_decision'][i_con]\n        if architectural_decision.do_assert(architecture_file):    # It means the variable has to be disactivated\n            xpath_no_root = xpath.split('/', 2)[2]\n            try:    # Delete process is different depending if the delete takes place in a direct child of the root or not\n                parent = xpath_no_root.rsplit(\"/\", 1)[0]\n                child = xpath_no_root.rsplit(\"/\", 1)[1]\n                for possible_parent in root.findall(parent):\n                    children = possible_parent.findall(child)\n                    for possible_child in children:\n                        possible_parent.remove(possible_child)\n                    possible_parent.text = possible_parent.text[:-1]\n            except:\n                parent = xpath_no_root\n                for possible_parent in root.findall(parent):\n                    root.remove(possible_parent)\n                root_removal = True\n\n\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = None\ndeactivation_logic = {'Xpath': ['/disciplines/C/Surface', '/disciplines/C/Volume'], 'Architectural_decision': [ElStrEq('/disciplines/Architecture/Method', 'Volume'), ElStrEq('/disciplines/Architecture/Method', 'Surface')]}\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "8a093866-6b39-4bcc-9339-18b52a02686c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "0a29e797-8904-4aff-8de6-d7a098878f76",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "e5a5aafd-4a71-41d1-a468-7f9d5bc8c63d",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "38aa19f5-640e-4d2d-a746-ca6d43b6c1ba",
    "name" : "Obj_input_filter",
    "location" : "1955:1280",
    "zIndex" : "28",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/C |\n\t\t\t/disciplines/y/output_y |\n\t\t\t/disciplines/z/output_z\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/C |\n\t\t\t/disciplines/y/output_y |\n\t\t\t/disciplines/z/output_z\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "66d98cc4-ecef-4d62-8000-4f73edcabca8",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "6e7d4d57-79ea-48ee-a0d7-98f43b2a8c36",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "bf4b1995-d556-4a45-b1e1-f6b32aadadc7",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "62b6f5ef-5486-4397-b8b9-6cbff6a4c2d1",
    "name" : "Obj_merge_script",
    "location" : "2120:1350",
    "zIndex" : "30",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "25930615-a513-4590-ae7d-1e823aad0a93",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "52811f7e-a499-4e8e-996d-fb7ce9f92d9f",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "47102bcb-e903-4273-92ba-dfed0b87c45d",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c93d9226-5123-4554-ac68-3e3d867a317e",
    "name" : "Obj_output_filter",
    "location" : "2045:1370",
    "zIndex" : "29",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/Objective\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/Objective\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "53fb480f-9934-41a8-af2c-7d499b3b763e",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "4bad2812-dc1c-4fe2-9adb-f3c038c0165e",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "1c8b8f11-2625-45ef-8400-5442e7af9ca9",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "b4bde488-fce9-483a-a8be-170f7f1c6b02",
    "name" : "Y_activation_logic",
    "location" : "255:60",
    "zIndex" : "4",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# This script is used in order to determine if a tool has to be activated or not.\n# To achieve that, what is done is to check the assertion expressing the condition for the\n# activation of the tool.\n# In case that the assertion is true, then the boolean called statement is True, in the opposite\n# case it will be false, disactivating the tool\n\n# Code is original\n\nimport os\nimport re\nimport time\nimport random\nimport glob\nfrom xml.etree import ElementTree as et\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n\n\ndef check_activation_logic(tool_activation_logic):\n    # The reference file is read\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n    activation = tool_activation_logic.do_assert(architecture_file)    # Assertion is checked\n\n\n    # XML and statement\n    root = et.parse(base_path_renamed).getroot()\n    tree = et.ElementTree(root)\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n    RCE.write_output(\"statement\", activation)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\n#tool_activation_logic is inputted here\ntool_activation_logic = XPathExists('/disciplines/y')\n\n#Assertion is checked\ncheck_activation_logic(tool_activation_logic)",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "d0c5e8dc-7b35-45d2-ac26-903a35c45e80",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "86bbaf87-5f9a-4744-8ec3-0c7419f73c1b",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "bea7ebb5-ae8c-4106-a710-23af77573689",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "42f5c52c-91c3-4601-97e5-e1d39b4da0b1",
    "name" : "Y_fourier",
    "location" : "235:310",
    "zIndex" : "34",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Y_fourier",
      "version" : "1.0",
      "name" : "Y_fourier"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "74ac1511-570e-4ee1-816f-fd0888aa056a",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "707242c3-ff12-4b26-9d20-cd7ec7b2a1f7",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "2e55ab1c-041c-4f69-ad12-17ac6aba0b63",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "name" : "Y_global_to_local",
    "location" : "350:220",
    "zIndex" : "9",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/disciplines/y[@UID=\"y_{INDEX}\"]/A', '/disciplines/x', '/disciplines/y[@UID=\"y_{INDEX}\"]/wa']\n    xpath_out = ['/disciplines/y[@UID=\"y_{INDEX}\"]/output_y', '/disciplines/y[@UID=\"y_{INDEX}\"]/c']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n    tool_activation_logic = XPathExists('/disciplines/y')\n    activation_str = repr(tool_activation_logic)\n    flag = 0\n    while flag == 0:\n        if \"INDEX\" in activation_str:\n            tool_activation_logic = parse_expression(activation_str.replace(\"{INDEX}\", str(index)))\n        activation = tool_activation_logic.do_assert(architecture_file)\n        if activation == True:\n            flag = 1\n        else:\n            index = index + 1\n\n\n\n\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/disciplines', 'y')\ndeactivation_logic = None\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "dd0c8249-6f2d-4b86-9555-dacf6ed10543",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "6e0499de-4bf9-4adc-be4c-f85a9aa38dff",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "4e06f56d-50df-4636-955b-4baab14937d6",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "12a3e2f4-e9d9-4d51-93ca-92b6b22d47eb",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "9cc8d2a6-60c1-476e-8980-dc1f9358d6f3",
    "name" : "Y_input_filter",
    "location" : "255:240",
    "zIndex" : "0",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/x |\n\t\t\t/disciplines/y[@UID='y_{INDEX}']/A |\n\t\t\t/disciplines/y[@UID='y_{INDEX}']/wa\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/x |\n\t\t\t/disciplines/y[@UID='y_{INDEX}']/A |\n\t\t\t/disciplines/y[@UID='y_{INDEX}']/wa\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "d7f55193-7a1c-408c-847d-513a69c764e6",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "2c9c2f75-b55c-4636-93f4-95db8f372ed1",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "95ac9085-276d-4a08-8dc5-d676d121832e",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "3a1a149a-6f20-45b7-a1e7-3805de0418b7",
    "name" : "Y_iterator",
    "location" : "720:310",
    "zIndex" : "6",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "a08daef0-c41b-4872-b963-5a2c85d6d74f",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "9827f8f4-7233-4b47-b4fb-f7b91c429459",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "ea9506ab-e323-4662-bebe-66b942df17e4",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "57bf2b55-1470-4ce3-be34-f906124822aa",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "c2e8f749-63da-44d7-a744-a2434e831e92",
    "name" : "Y_joiner_activation",
    "location" : "645:330",
    "zIndex" : "5",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "825b748e-e690-4612-a9f7-85230f6c5784",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "779484ed-932f-4d3b-942f-cad5a5d3dcc5",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "5bb197a2-e16b-4167-bbd8-c07c0cdb0ea9",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "f19e4168-a6ff-400f-ac92-89a482fc1622",
    "name" : "Y_joiner_repetition",
    "location" : "370:150",
    "zIndex" : "8",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "729bbb76-e7cb-40d6-81a7-0afa331b0a07",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "a7210084-884b-47ca-a86b-be9bd834f6ea",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "670714c6-9b7a-4f44-8761-0628189cf3ee",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "e097238b-03d2-447e-9a6c-b5bbf9bf8c1f",
    "name" : "Y_local_to_global",
    "location" : "420:310",
    "zIndex" : "10",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "2a7dae62-2540-444a-91d4-ee56c341629b",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "46547060-f6d7-4d01-87c7-75038e8c939a",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "33ec7eda-2f4d-4def-be57-42b5df22b6ca",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "4b8cd9a7-e7ba-43ac-82c8-62f79ab40d9d",
    "name" : "Y_merge_script",
    "location" : "535:310",
    "zIndex" : "2",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "a43d88df-f644-492b-b04f-e2443ac0d317",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "71af32ea-f46b-4172-b96e-2d1e8a9ec7db",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "4aa3c4ec-5102-409b-8b38-5fb1ef11f41a",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "46c93cbd-ea5e-4626-9a00-c5a7804d49fd",
    "name" : "Y_output_filter",
    "location" : "345:330",
    "zIndex" : "1",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/y/output_y\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/y/c |\n\t\t\t/disciplines/y/output_y\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "0c3700f8-bf40-4856-83c7-6ffbff83d815",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "da3fdf3c-566e-4262-8feb-960e376d9151",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "09da53a0-25e4-42f3-bc38-bcab64037093",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "5bab2336-4846-4328-9c79-845c7114df60",
    "name" : "Y_repetition_switch",
    "location" : "830:330",
    "zIndex" : "7",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "f50bee6d-0b14-4108-b1ca-bfc3cbe8b9ad",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "c0de3f88-ae2d-4b43-8acc-c0dc1418b45a",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "5951f1db-f23a-47c5-a6e3-a933bd8d4a7c",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "8d6c836b-4d83-41d7-b265-1425b9346362",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58",
    "name" : "Y_switch_activation",
    "location" : "370:80",
    "zIndex" : "3",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "a1b4222c-81b2-4cd2-8efc-28d493c2d955",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "d24be319-8ad8-4e15-ad7f-c9795e374078",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "44e0541a-dfc7-4900-b09e-2c9c953b8d9f",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "cedd32c1-ea85-4e23-9a1e-9c6b5f327a24",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c7c9f374-19e2-407d-880a-1eec31dda65e",
    "name" : "Z_activation_logic",
    "location" : "905:490",
    "zIndex" : "15",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# This script is used in order to determine if a tool has to be activated or not.\n# To achieve that, what is done is to check the assertion expressing the condition for the\n# activation of the tool.\n# In case that the assertion is true, then the boolean called statement is True, in the opposite\n# case it will be false, disactivating the tool\n\n# Code is original\n\nimport os\nimport re\nimport time\nimport random\nimport glob\nfrom xml.etree import ElementTree as et\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n\n\ndef check_activation_logic(tool_activation_logic):\n    # The reference file is read\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n    activation = tool_activation_logic.do_assert(architecture_file)    # Assertion is checked\n\n\n    # XML and statement\n    root = et.parse(base_path_renamed).getroot()\n    tree = et.ElementTree(root)\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n    RCE.write_output(\"statement\", activation)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\n#tool_activation_logic is inputted here\ntool_activation_logic = XPathExists('/disciplines/z')\n\n#Assertion is checked\ncheck_activation_logic(tool_activation_logic)",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "300cc95b-08c1-451e-b19c-e3488d552ad2",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "6600cb33-7c23-41e8-a204-4b94b2a2cb53",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "72e739d7-5a6c-4281-95db-ea38caae768a",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "0459299e-2c7d-4502-a36b-4e4d15ee2ced",
    "name" : "Z_fourier",
    "location" : "885:740",
    "zIndex" : "35",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.integration.cpacs.Z_fourier",
      "version" : "1.0",
      "name" : "Z_fourier"
    },
    "configuration" : {
      "chosenDeleteTempDirBehavior" : "deleteWorkingDirectoriesAfterWorkflowExecution",
      "storeComponentHistoryData" : "true"
    },
    "staticInputs" : [ {
      "identifier" : "b60c39b3-859e-4a44-bd61-f04b9256256e",
      "name" : "CPACS initial",
      "datatype" : "FileReference",
      "metadata" : {
        "endpointFileName" : "CPACS_initial.xml"
      }
    } ],
    "staticOutputs" : [ {
      "identifier" : "df359d33-f814-49ab-9c5d-30727b7429c3",
      "name" : "CPACS out",
      "datatype" : "FileReference"
    }, {
      "identifier" : "fba33e00-aa9a-423d-8cfa-7fb8c7540b28",
      "name" : "Return directory",
      "datatype" : "DirectoryReference"
    } ]
  }, {
    "identifier" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "name" : "Z_global_to_local",
    "location" : "1000:650",
    "zIndex" : "20",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport re\nimport os\nimport ast\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\nclass Architecture:\n\n    def __init__(self, name, xml_tree):\n        self.name = name\n        self._tree = xml_tree\n\n    @property\n    def tree(self):\n        return self._tree\n\n    @classmethod\n    def from_file(cls, path, name=None):    # Read xml from file\n        if name is None:\n            name = os.path.basename(os.path.splitext(path)[0])\n        xml_tree = et.parse(path)\n        return cls(name, xml_tree)\n\n\n\n    def get_elements(self, xpath):    # Determine if a xpath exists\n        start_tag = \"/\" + str(self._tree.getroot().tag)    # Here you obtain the element directly\n        if xpath.startswith(start_tag):\n            xpath = \".\" + str(xpath[len(start_tag):])\n        else:\n            xpath = \".\" + str(xpath)\n\n        return self._tree.findall(xpath)    # Here you obtain the 0 or the 1\n\nimport fnmatch\nimport math\n\n__all__ = ['Assertion', 'parse_expression',\n           'XPathExists', 'XPathNEq', 'XPathNGt', 'XPathNLt',\n           'ElHasValue', 'ElStrEq', 'ElStrContains', 'ElNumEq', 'ElNumGt', 'ElNumLt'\n]\n\n\nclass Assertion(object):\n\n    def do_assert(self, arch):\n        raise NotImplementedError\n\n    def __invert__(self):  # \"not\" operator ~\n        return NotAssertion(self)\n\n    def __and__(self, other):  # \"and\" operator &\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return AndAssertion(self, other)\n\n    def __or__(self, other):  # \"or\" operator |\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return OrAssertion(self, other)\n\n    def __xor__(self, other):  # \"xor\" operator ^\n        if not isinstance(other, Assertion):\n            raise NotImplementedError\n        return XorAssertion(self, other)\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass UnaryAssertion(Assertion):\n\n    def __init__(self, assertion):\n        self._assert = assertion\n\n    def do_assert(self, arch):\n        return self._apply(self._assert.do_assert(arch))\n\n    def _apply(self, assertion):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass NotAssertion(UnaryAssertion):\n\n    def _apply(self, assertion):\n        return not assertion\n\n    def __repr__(self):\n        return \"~{class_name}\".format(class_name=self._assert)\n\n\n\n\nclass BinaryAssertion(Assertion):\n\n    def __init__(self, assertion1, assertion2):\n        self._assert1 = assertion1\n        self._assert2 = assertion2\n\n    def do_assert(self, arch):\n        assert1 = self._assert1.do_assert(arch)\n        assert2 = self._assert2.do_assert(arch)\n        return self._apply(assert1, assert2)\n\n    def _apply(self, assertion1, assertion2):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass AndAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 and assertion2\n\n    def __repr__(self):\n        return \"{class_name1} & {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass OrAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 or assertion2\n\n    def __repr__(self):\n        return \"{class_name1} | {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XorAssertion(BinaryAssertion):\n\n    def _apply(self, assertion1, assertion2):\n        return assertion1 != assertion2\n\n    def __repr__(self):\n        return \"{class_name1} ^ {class_name2}\".format(class_name1=self._assert1, class_name2=self._assert2)\n\n\nclass XPathAssertion(Assertion):\n\n    def __init__(self, xpath):\n        self._xpath = xpath    # Why here we donÂ´t need the super???? Because xpath was not defined before\n\n    def do_assert(self, arch):\n        return self._assert(arch.get_elements(self._xpath))\n\n    def _assert(self, els):    # General call. Each assertion has each own method\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass XPathExists(XPathAssertion):\n    \"\"\"Asserts if nodes at some xpath exist\"\"\"\n\n    def _assert(self, els):\n        return len(els) > 0\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\n\nclass XPathNEq(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is equal to given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNEq, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) == self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\n\nclass XPathNGt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is greater than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNGt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) > self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass XPathNLt(XPathAssertion):\n    \"\"\"Asserts if the amount of nodes at some xpath is lower than given number\"\"\"\n\n    def __init__(self, xpath, n):\n        super(XPathNLt, self).__init__(xpath)\n        self._n = n\n\n    def _assert(self, els):\n        return len(els) < self._n\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._n)\n\n\nclass ElValueAssertion(XPathAssertion):    # Base class for string assertions\n\n    def _assert(self, els):\n        el_text = els[0].text if len(els) > 0 else None\n        return self._assert_value(el_text)\n\n    def _assert_value(self, el_text):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElHasValue(ElValueAssertion):\n    \"\"\"Asserts if the first element at some xpath has a value (False if element doesn't exist)\n       For this class any element (string or number) will trigger a True value\"\"\"\n\n    def _assert_value(self, el_text):\n        return bool(el_text)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}')\".format(class_name=self.__class__.__name__, xpath=self._xpath)\n\n\nclass ElStrEq(ElValueAssertion):\n    \"\"\"Asserts if the element value equals (string); can also use wildcards\"\"\"\n\n    def __init__(self, xpath, value):\n        super(ElStrEq, self).__init__(xpath)\n        self._value = value\n\n    def _assert_value(self, el_text):\n        if not isinstance(el_text, str):\n            return False\n        if el_text == self._value:\n            return True\n        return fnmatch.fnmatch(el_text, self._value)\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._value)\n\n\n\nclass ElStrContains(ElStrEq):\n    \"\"\"Asserts if the element value (string) contains some substring\"\"\"\n\n    def __init__(self, xpath, substring):    # Here is calling parent class, but with substring **\n        super(ElStrContains, self).__init__(xpath, \"*\" + str(substring) + \"*\")\n        self._sub = substring\n\n    def __repr__(self):\n        return \"{class_name}('{xpath}', '{value}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, value=self._sub)\n\n\nclass ElNumValueAssertion(XPathAssertion):\n\n    def _assert(self, els):\n        if len(els) == 0:\n            return False\n        el_text = els[0].text\n        try:                             # We check if it is a number\n            value = float(el_text)\n        except (ValueError, TypeError):\n            return False\n        if math.isnan(value):            # Check if Nan\n            return False\n        return self._assert_value(value)\n\n    def _assert_value(self, value):\n        raise NotImplementedError\n\n    def __repr__(self):\n        raise NotImplementedError\n\n\nclass ElNumEq(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value and that it equals a given value; optionally with rel/abs tol\"\"\"\n\n    def __init__(self, xpath, value, rel_tol=None, abs_tol=None):\n        super(ElNumEq, self).__init__(xpath)\n        self._value = value\n        self._rel_tol = rel_tol\n        self._abs_tol = abs_tol\n\n    def _assert_value(self, value):\n        if self._rel_tol is not None or self._abs_tol is not None:\n            diff = abs(value-self._value)\n            if self._rel_tol is not None and diff < self._value*self._rel_tol:\n                return True\n            if self._abs_tol is not None and diff < self._abs_tol:\n                return True\n            return False\n\n        return value == self._value\n\n    def __repr__(self):\n        rel_tol_str = None if self._rel_tol is None else \"rel_tol={tol}\".format(tol=self._rel_tol)\n        abs_tol_str = None if self._abs_tol is None else \"abs_tol={tol}\".format(tol=self._abs_tol)\n        if rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str, abs_tol= abs_tol_str)\n        elif rel_tol_str and not abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {rel_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, rel_tol=rel_tol_str)\n        elif not rel_tol_str and abs_tol_str:\n            return \"{class_name}('{xpath}', {number}, {abs_tol})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value, abs_tol= abs_tol_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._value)\n\n\nclass ElNumGt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value greater than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumGt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value >= self._ref\n        return value > self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath, number=self._ref)\n\n\nclass ElNumLt(ElNumValueAssertion):\n    \"\"\"Asserts if the element has a numerical value lower than (or equal to if eq=True) than some reference\"\"\"\n\n    def __init__(self, xpath, ref, eq=False):\n        super(ElNumLt, self).__init__(xpath)\n        self._ref = ref\n        self._eq = eq\n\n    def _assert_value(self, value):\n        if self._eq:\n            return value <= self._ref\n        return value < self._ref\n\n    def __repr__(self):\n        eq_str = 'eq=True' if self._eq else None\n        if eq_str:\n            return \"{class_name}('{xpath}', {number}, {eq})\".format(class_name=self.__class__.__name__,\n                                                                    xpath=self._xpath, number=self._ref, eq=eq_str)\n        else:\n            return \"{class_name}('{xpath}', {number})\".format(class_name=self.__class__.__name__, xpath=self._xpath,\n                                                              number=self._ref)\n\n\ndef parse_expression(expression):\n    # Check for wrong operator use\n    if ' and ' in expression or ' or ' in expression or 'not ' in expression:\n        raise RuntimeError('Use following logical operators instead of and/or/not: &, |, ~')\n\n    eval_globals = {'__builtins__': None}\n    for class_name in __all__[2:]:    # We check all the different types of assertions\n        eval_globals[class_name] = globals()[class_name]\n\n    try:\n        assertion = eval(expression, eval_globals)\n    except Exception:\n        raise RuntimeError(\"Could not evaluate expression:\\n\" + str(expression))\n\n    if not isinstance(assertion, Assertion):\n        raise RuntimeError(\"Expression does not result in an Assertion:\\n\" + str(expression))\n    return assertion\n   # Might be all or just some depending on the case scenario\nclass NumberofInstances(XPathAssertion):\n\n    \"\"\"Determines the number of child nodes with a certain tag\"\"\"\n\n\n\n    def __init__(self, xpath, instance):\n\n        super(NumberofInstances, self).__init__(xpath)\n\n        self._instance = instance\n\n\n\n    def _assert(self, els):\n\n        instance = self._instance\n\n        counter = 0\n\n        for element in els:\n\n            counter = counter + len(element.findall(instance))\n\n        return counter\n\n\n\n    def __repr__(self):\n\n        return \"{class_name}('{xpath}', '{instance}')\".format(class_name=self.__class__.__name__, xpath=self._xpath, instance=self._instance)\n\n\n\n\n\n\n\ndef Global_to_local(assertion_repetition, deactivation_logic):\n\n\n\n    base_path = RCE.read_input(\"XML\")\n\n    # Rename input file, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n\n    # The given file is passed to the merger as it is. Another one is modified for the input\n    RCE.write_output(\"XML_outputs\", base_path_renamed)\n\n    architecture_file = Architecture.from_file(base_path_renamed)    # Main file is converted to architecture\n\n    # XML and statement\n    tree = et.parse(base_path_renamed)\n    root = tree.getroot()\n\n    if isinstance(assertion_repetition,int):\n        number_of_repetitions = assertion_repetition\n    else:\n        number_of_repetitions = assertion_repetition.do_assert(architecture_file)    # Assertion is checked\n\n    xpath_in = ['/disciplines/z[@UID=\"z_{INDEX}\"]/B', '/disciplines/x', '/disciplines/z[@UID=\"z_{INDEX}\"]/wb']\n    xpath_out = ['/disciplines/z[@UID=\"z_{INDEX}\"]/output_z', '/disciplines/z[@UID=\"z_{INDEX}\"]/c']\n\n\n    # It is needed to know at what iteration the workflow is\n    index = RCE.read_state_variable (\"iteration\")\n    if index is None:\n        index = 1\n\n    index_iter = RCE.read_state_variable (\"index_iteration\")\n    if index_iter is None:\n        index_iter = 1\n\n    tool_activation_logic = XPathExists('/disciplines/z')\n    activation_str = repr(tool_activation_logic)\n    flag = 0\n    while flag == 0:\n        if \"INDEX\" in activation_str:\n            tool_activation_logic = parse_expression(activation_str.replace(\"{INDEX}\", str(index)))\n        activation = tool_activation_logic.do_assert(architecture_file)\n        if activation == True:\n            flag = 1\n        else:\n            index = index + 1\n\n\n\n\n\n\n\n    xpaths_output = []\n    values_output = []\n    keys_output = []\n\n    # Inputs are iterated before outputs. Changes to the workflow xml are introduced here. These are the uid tags rename\n    for xpath in xpath_in:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            xpath_to_search_no_number = re.findall(r\".*{INDEX}.*?/\", xpath_no_root)[0][:-1]\n            xpath_check = xpath_to_search_no_number.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n\n\n            try:  # Might have been changed already before\n                root.find(xpath_check).attrib[key_repetition] = value_index\n            except:\n                pass\n\n    for xpath in xpath_out:\n        xpath_no_root = xpath.split(\"/\", 2)[2]\n        if \"INDEX\" in xpath_no_root:\n            repetition_attribute = re.findall(\"\\@[^\\@]*{INDEX}.*?\\\"\", xpath_no_root)[0]\n            value_index = re.search('@[^=]+=\"([^\"]+)\"', repetition_attribute).group(1)\n\n            value_repetition = value_index.replace(\"{INDEX}\", str(index))\n            key_repetition = re.search(\"@([^=]+)=\", repetition_attribute).group(1)\n            xpath_to_save_repetition = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0]\n            xpath_for_rest_of_attributes = re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[0] + re.split(r\"\\[[^\\[]*{INDEX}.*?]\", xpath_no_root)[1]\n            if \"@\" in xpath_to_save_repetition:\n                attributes = re.findall(\"\\[@.*?]\", xpath_for_rest_of_attributes)\n                xpath_iteration = xpath_for_rest_of_attributes\n                for element in attributes:\n                    keys_output.append(re.search(\"@([^=]+)=\", element).group(1))\n                    values_output.append(re.search('@[^=]+=\"([^\"]+)\"', element).group(1))\n                    xpath_split = re.split(\"\\[@.*?]\", xpath_iteration, 1)\n                    xpaths_output.append(xpath_split[0])\n                    xpath_iteration = xpath_split[0] + xpath_split[1]\n\n\n            keys_output.append(key_repetition)\n            values_output.append(value_repetition)\n            xpaths_output.append(xpath_to_save_repetition)\n\n\n    input_file = RCE.create_input_file()\n    file = input_file.write_to_file(\"g_l\")\n\n    f = open(file, 'w')\n    f.write(str(xpaths_output) + \"\\n\")\n    f.write(str(keys_output) + \"\\n\")\n    f.write(str(values_output) + \"\\n\")\n    f.write (str(number_of_repetitions))\n    RCE.write_output(\"xpaths_uids\", file)\n    if index_iter == number_of_repetitions:\n        RCE.write_state_variable (\"iteration\", 1)\n        RCE.write_state_variable (\"index_iteration\", 1)\n    else:\n        RCE.write_state_variable (\"iteration\", index+1)\n        RCE.write_state_variable (\"index_iteration\", index_iter+1)\n\n\n\n    # Output xml\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML_inputs\", output_path)\n\n\n\n\n\n\nassertion_repetition = NumberofInstances('/disciplines', 'z')\ndeactivation_logic = None\nglobal_to_local = Global_to_local(assertion_repetition, deactivation_logic)\n",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "407e2f9f-91c5-4dff-a220-d057ef0b650c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "dee1e7e0-6264-4846-aaac-78591543953e",
      "name" : "XML_inputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "34ac6cb2-81ae-4177-886b-0b507dfa354d",
      "name" : "XML_outputs",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "6f9b041e-2c56-4f93-8937-0b8f54c64b90",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "e3167185-7e42-4bf2-8054-d026df653550",
    "name" : "Z_input_filter",
    "location" : "905:670",
    "zIndex" : "11",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/x |\n\t\t\t/disciplines/z[@UID='z_{INDEX}']/B |\n\t\t\t/disciplines/z[@UID='z_{INDEX}']/wb\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/x |\n\t\t\t/disciplines/z[@UID='z_{INDEX}']/B |\n\t\t\t/disciplines/z[@UID='z_{INDEX}']/wb\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "f6061b9f-6b0c-404a-acce-00b5e3c97f00",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "ac2e310d-08bf-4394-8bb1-00e4cfc75ad8",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "3aa3ee08-fa64-4d47-a1f9-f24fe019de67",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "377a00f7-a686-490d-b8d0-81ba775ecf7b",
    "name" : "Z_iterator",
    "location" : "1370:740",
    "zIndex" : "17",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "import re\n\n\nindex = RCE.read_state_variable (\"iteration\")\nif index is None:\n    index = 1    # Iterations finished\n\n\nbase_path = RCE.read_input(\"XML\")\n\ntry:\n    file_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\n    with open(file_xpaths_uids, \"r\") as f:\n        lines = f.readlines()\n\n    repetitions = int(lines[3])\nexcept:    # This is a zero run loop in case of repetition plus activation\n    repetitions = 1\n\nRCE.write_output(\"XML\", base_path)\n\n\nif index == repetitions:\n    RCE.write_output(\"statement\", True)\n    RCE.write_state_variable (\"iteration\",1)\r\n    RCE.close_all_outputs()\nelse:\n    RCE.write_output(\"statement\", False)\n    RCE.write_state_variable (\"iteration\",index+1)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "16b8c63a-5a5c-4c12-b3ab-e35bbfb33c3c",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "4e25f6f8-8c1c-49c1-9257-5ecd36bb36e6",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "NotRequired",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "0fdaf92d-1b98-4f88-87e9-70378281e2fa",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    }, {
      "identifier" : "0996c8bd-4518-46d2-acc5-0f0f9c0a1341",
      "name" : "statement",
      "epIdentifier" : "default",
      "datatype" : "Boolean"
    } ]
  }, {
    "identifier" : "7fb271d6-911a-4606-993e-84551298e8bc",
    "name" : "Z_joiner_activation",
    "location" : "1295:760",
    "zIndex" : "16",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "80607db7-560a-4b03-970f-378d4fe1621f",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "a7e63361-e808-4150-899c-85bc8f64d009",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "6f003384-016e-4e3e-b453-1fc1a59314d1",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "2de3f637-ae8f-42c3-8aef-9e8abce7b0f5",
    "name" : "Z_joiner_repetition",
    "location" : "1020:580",
    "zIndex" : "19",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.joiner",
      "version" : "3.3",
      "name" : "Joiner"
    },
    "configuration" : {
      "datatype" : "FileReference",
      "inputCount" : "2",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "06cb71c1-342b-40e3-bd55-5fe0ee79d418",
      "name" : "Input 001",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    }, {
      "identifier" : "d2f0f42b-52ea-42fd-a52c-81aff5464e29",
      "name" : "Input 002",
      "epIdentifier" : "toJoin",
      "group" : "join",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "90484345-9597-4f2b-b87b-2837d9ea0ead",
      "name" : "Joined",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "21d6fbc2-88d5-4a39-8ca8-f8fcf7134898",
    "name" : "Z_local_to_global",
    "location" : "1070:740",
    "zIndex" : "21",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "from xml.etree import ElementTree as et\nimport re\nimport time\nimport random\nimport glob\nimport os\nimport ast\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nbase_path = RCE.read_input(\"XML\")\n# Rename input file, otherwise RCE will not update input files in subsequent script executions\nbase_path_renamed = random_rename(base_path)\nos.rename(base_path, base_path_renamed)\n\n# XML and statement\ntree = et.parse(base_path_renamed)\nroot = tree.getroot()\n\n# We read the list of outputs and their uids.\n\nfile_xpaths_uids = RCE.read_input(\"xpaths_uids\")\n\nwith open(file_xpaths_uids, \"r\") as f:\n    lines = f.readlines()\n\nxpaths_output = ast.literal_eval(lines[0])\nkeys_output = ast.literal_eval(lines[1])\nvalues_output = ast.literal_eval(lines[2])\n\nfor i in range(len(xpaths_output)):\n     xpath = xpaths_output[i]\n     key = keys_output[i]\n     value = values_output[i]\n     root.find(xpath).set(key, value)\n\n\n# Output xml\noutput_path = random_rename(base_path, same_path=False)\nf_base = open(output_path, \"wb\")\ntree.write(f_base, encoding=\"utf-8\")\nf_base.close()\nRCE.write_output(\"XML\", output_path)\n\ndef random_rename(file_path, same_path=True):\n    file_name, file_ext = os.path.splitext(file_path)\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)",
      "scriptLanguage" : "Python",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "203ebcb0-e4ea-46cf-80bd-1da5ef8629db",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "4b00b62f-6a2d-4f7d-8f96-0a0432cde4d1",
      "name" : "xpaths_uids",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "f5c37798-5ad5-45c8-9e41-f555d7a2f963",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "c1b2486c-83d8-43d3-a809-3a592d7a7940",
    "name" : "Z_merge_script",
    "location" : "1185:740",
    "zIndex" : "13",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.script",
      "version" : "3.5",
      "name" : "Script"
    },
    "configuration" : {
      "pythonExecutionPath" : "${pythonExecutionPath}",
      "script" : "# This script is converted to a string and used in a \"script\" component in RCE. It is compiled with Jython.\n\n# The script merges the `base` and `merge` files. Equal elements from the `merge` file have precedence.\n# More than one `merge` files are possible (must be appropriately modeled in the workflow).\n# Equal Elements from latter files take precedence.\n# Equality between elements is determined according to their ancestry, tag and attributes.\n# If element does not have attributes, its position as child node is taken as attribute.\n\n# Code is adapted from https://stackoverflow.com/a/29896847\n\nimport os\nimport re\nimport xml\nimport time\nimport random\nfrom uuid import uuid4\nfrom xml.etree import ElementTree as et\n\nMARK_SVM_ATTR = '__sub_value'\n\n\ndef merge_files():\n    # f_base in first pos\n    base_path, merge_path = RCE.read_input(\"XML\"), RCE.read_input(\"XML to integrate\")\n\n    # rename input files, otherwise RCE will not update input files in subsequent script executions\n    base_path_renamed = random_rename(base_path)\n    os.rename(base_path, base_path_renamed)\n    merge_path_renamed = random_rename(merge_path)\n    os.rename(merge_path, merge_path_renamed)\n\n    merged_tree = XMLCombiner([base_path_renamed, merge_path_renamed]).combine()\n\n    # write output tree to file and output variable\n    output_path = random_rename(base_path, same_path=False)\n    f_base = open(output_path, \"wb\")\n    merged_tree.write(f_base, encoding=\"utf-8\")\n    f_base.close()\n    RCE.write_output(\"XML\", output_path)\n\n\ndef random_rename(file_path, same_path=True):\n    file_name_0, file_ext = os.path.splitext(file_path)\n    file_name = re.split(\"_renamed\", file_name_0)[0]\n    renamed_file = file_name + \"_renamed_\" + str(int(time.time() * 1000)) + \"_\" + str(\n        int(random.randint(0, 1000000))) + file_ext\n    if not same_path:\n        return renamed_file\n    return os.path.join(os.path.dirname(file_path), renamed_file)\n\n\nclass hashabledict(dict):\n\n    def __hash__(self):\n        return hash(tuple(sorted(self.items())))\n\n\nclass XMLIndexTracker(object):\n    \"\"\"Tracks the index of similar xml elements.\"\"\"\n\n    def __init__(self):\n        self._map = {}\n\n    def __call__(self, element):\n        id = element_id(element)\n        if not id in self._map:\n            self._map[id] = 0\n        else:\n            self._map[id] += 1\n\n        return self._map[id]\n\n\nclass XMLCombiner(object):\n\n    def __init__(self, filenames):\n        assert len(filenames) > 0, \"No filenames!\"\n        # save all the roots, in order, to be processed later\n        # self.roots = [et.parse(f).getroot() for f in filenames]\n        self.roots = []\n        for f in filenames:\n            try:\n                self.roots.append(et.parse(f).getroot())\n            except xml.parsers.expat.ExpatError:  # ignores files with no root elements\n                pass\n\n    def combine(self):\n        for r in self.roots[1:]:\n            # combine each element with the first one, and update that\n            self.combine_element(self.roots[0], r)\n\n        # strip sub value matching marking attributes\n        self.unmark_svm(self.roots[0])\n\n        # return the string representation\n        try:\n            return et.ElementTree(self.roots[0])\n        except IndexError:\n            raise IndexError(\"All files are empty!\")\n\n    def unmark_svm(self, root):\n        for desc_node in root.getiterator():\n            desc_node.attrib.pop(MARK_SVM_ATTR, None)\n\n    def combine_element(self, one, other):\n        \"\"\"\n        This function recursively updates either the text or the children\n        of an element if another element is found in `one`, or adds it\n        from `other` if not found.\n        \"\"\"\n        # initialize index trackers\n        track_one = XMLIndexTracker()\n        track_other = XMLIndexTracker()\n\n        # Create a mapping from tag name to element, as that`s what we are filtering with\n        mapping = dict((element_id(el, track_one(el)), el) for el in one)\n        for child in other:\n            c_idx = track_other(child)\n            if len(child) == 0:\n                # Not nested\n                try:\n                    # Update the text\n                    mapping[element_id(child, c_idx)].text = child.text\n                except KeyError:\n                    # An element with this name is not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Add it\n                    one.append(child)\n            else:\n                try:\n                    # Recursively process the element, and update it in the same way\n                    self.combine_element(mapping[element_id(child, c_idx)], child)\n                except KeyError:\n                    # Not in the mapping\n                    mapping[element_id(child, c_idx)] = child\n                    # Just add it\n                    one.append(child)\n\n\ndef element_attr(element):\n    \"\"\"Returns element hashable attr dict.\"\"\"\n    return hashabledict(element.attrib) if element.attrib else hashabledict({})\n\n\ndef element_id(element, idx=None):\n    if idx is not None:\n        return (element.tag, element_attr(element), idx)\n    return (element.tag, element_attr(element))\n\n\nmerge_files()\n",
      "scriptLanguage" : "Jython",
      "storeComponentHistoryData" : "true",
      "usageOfScript" : "NEW"
    },
    "dynamicInputs" : [ {
      "identifier" : "eb593e79-8ca5-48ef-9553-2b22ffbc558d",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "6a38a0c6-a176-4cac-9ff8-0d3e5b129e0a",
      "name" : "XML to integrate",
      "epIdentifier" : "default",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "4e86b1f3-ffbe-4aa9-8876-67023c05024d",
      "name" : "XML",
      "epIdentifier" : "default",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "9d52ce6b-8118-4be1-bd30-c85e85d97103",
    "name" : "Z_output_filter",
    "location" : "995:760",
    "zIndex" : "12",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.xmlmerger",
      "version" : "4.0",
      "name" : "XML Merger"
    },
    "configuration" : {
      "mappingFileDeployment" : "loaded",
      "mappingType" : "XSLT",
      "storeComponentHistoryData" : "true",
      "xmlContent" : "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" exclude-result-prefixes=\"xsi\">\n\t<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/>\n\n\t<!-- Filter by XPATHS -->\n\n\t<xsl:template match=\"*[descendant::node() intersect (\n\t\t\t/disciplines/z/c |\n\t\t\t/disciplines/z/output_z\n\t\t)]\" priority=\"1\">\n\t\t<xsl:copy>\n\t\t\t<xsl:copy-of select='@*'/>\n\t\t\t<xsl:apply-templates select='*'/>\n\t\t</xsl:copy>\n\t</xsl:template>\n\n\t<xsl:template match=\"*[. intersect (\n\t\t\t/disciplines/z/c |\n\t\t\t/disciplines/z/output_z\n\t\t)]\" priority=\"2\">\n\t\t<xsl:copy-of select='.'/>\n\t</xsl:template>\n\n\t<!-- Mark sub value matching nodes -->\n\n\n\t<!-- remove unbound text -->\n\n\t<xsl:template match=\"text()\">\n\t\t<xsl:if test=\"preceding::comment() and following::comment()\"></xsl:if>\n\t</xsl:template>\n\n</xsl:stylesheet>"
    },
    "staticInputs" : [ {
      "identifier" : "264027fa-a136-462e-aacc-9a3c30c0441c",
      "name" : "XML",
      "datatype" : "FileReference"
    }, {
      "identifier" : "3e2ebba9-74da-46d6-9510-8c95b69b8d06",
      "name" : "XML to integrate",
      "datatype" : "FileReference"
    } ],
    "staticOutputs" : [ {
      "identifier" : "46901066-9195-4b64-bab0-2e60616a2a72",
      "name" : "XML",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "d9d6800f-d391-4a85-8320-34e956108685",
    "name" : "Z_repetition_switch",
    "location" : "1480:760",
    "zIndex" : "18",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "73c4244d-4b1d-4c31-85da-2c5822efbdbb",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "a40ca88a-24b8-4bdc-9b38-644a09f67919",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "408ebf20-5c43-4489-bb18-97551b48b755",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "f81efa93-1be4-4e04-96b8-eb33e4d986e5",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  }, {
    "identifier" : "49724794-3d9a-42c8-b68f-61f446a85ae5",
    "name" : "Z_switch_activation",
    "location" : "1020:510",
    "zIndex" : "14",
    "active" : "true",
    "component" : {
      "identifier" : "de.rcenvironment.switchcmp",
      "version" : "2.0",
      "name" : "Switch"
    },
    "configuration" : {
      "closeOutputsOnConditionNumber" : "false",
      "closeOutputsOnNoMatch" : "false",
      "conditionKey" : "[{\"conditionNumber\":1,\"conditionScript\":\"statement == True\"}]",
      "neverCloseOutputs" : "true",
      "storeComponentHistoryData" : "true"
    },
    "dynamicInputs" : [ {
      "identifier" : "c485256b-f039-40ec-9e8a-cbc4da8475d9",
      "name" : "XML",
      "epIdentifier" : "dataToInput",
      "datatype" : "FileReference",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    }, {
      "identifier" : "1793f188-7078-4576-b11e-ebff13489f4a",
      "name" : "statement",
      "epIdentifier" : "conditionToInput",
      "datatype" : "Boolean",
      "metadata" : {
        "inputExecutionConstraint_4aae3eea" : "Required",
        "inputHandling_73b1056e" : "Queue"
      }
    } ],
    "dynamicOutputs" : [ {
      "identifier" : "395b2cf3-2212-4641-aec8-c5839c0c4cee",
      "name" : "XML_condition 1",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    }, {
      "identifier" : "eb31703e-4216-4a2b-a7d3-640c4492d7ec",
      "name" : "XML_no match",
      "epIdentifier" : "dataToOutput",
      "datatype" : "FileReference"
    } ]
  } ],
  "connections" : [ {
    "source" : "217b6ae0-de43-458e-a356-883a583118e9",
    "output" : "8c015486-0046-4d4b-a5f6-a05949935f8b",
    "target" : "6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8",
    "input" : "5811ff0d-ba71-4532-82d0-d76890706e69"
  }, {
    "source" : "513fec3e-5bdf-4cb7-aff4-c908908ed612",
    "output" : "051e6c85-13f2-483d-99f9-fe1fd77d09d6",
    "target" : "217b6ae0-de43-458e-a356-883a583118e9",
    "input" : "935d8c06-7261-4bff-a7ba-5689e3628f37"
  }, {
    "source" : "09d714a2-1787-4c5a-8e58-c079d411300e",
    "output" : "9daaf3fc-a6e9-4d06-8b87-72c9712b28ca",
    "target" : "c9c1ca53-f895-46c5-b394-35f22cc12ef2",
    "input" : "2c24a3cb-6100-4b32-bf2c-25fe8a5ebcbe"
  }, {
    "source" : "09d714a2-1787-4c5a-8e58-c079d411300e",
    "output" : "9daaf3fc-a6e9-4d06-8b87-72c9712b28ca",
    "target" : "c9c1ca53-f895-46c5-b394-35f22cc12ef2",
    "input" : "466b7fe9-9bd2-4a18-9e89-9d62fc35a4c1"
  }, {
    "source" : "6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8",
    "output" : "8e196d40-2760-46dc-bd9a-4a4ec38fe4f4",
    "target" : "53b1231b-b3f8-4ca4-9769-dd64d0ff8de8",
    "input" : "85c97adf-4b82-4f1c-8a8e-1c832121503d"
  }, {
    "source" : "6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8",
    "output" : "8e196d40-2760-46dc-bd9a-4a4ec38fe4f4",
    "target" : "53b1231b-b3f8-4ca4-9769-dd64d0ff8de8",
    "input" : "b5a58f64-0fa5-400a-ab95-e7fb3c074d61"
  }, {
    "source" : "6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8",
    "output" : "0f81b1ae-fb66-475c-bc92-01aeaa55a2a5",
    "target" : "231202f3-ca0d-47a3-bf29-901d9740feb6",
    "input" : "e6fe65aa-d167-4e0a-b849-4851ac14611c"
  }, {
    "source" : "53b1231b-b3f8-4ca4-9769-dd64d0ff8de8",
    "output" : "87cd1d40-9cb3-4c96-a98b-091daad7dd43",
    "target" : "09d714a2-1787-4c5a-8e58-c079d411300e",
    "input" : "2ee995ee-5b84-4247-a173-22888e84911f"
  }, {
    "source" : "231202f3-ca0d-47a3-bf29-901d9740feb6",
    "output" : "61d7b054-aa6a-4db6-aab1-b4ea3375bdef",
    "target" : "c638b003-5fbd-43a3-a173-3f93765662ab",
    "input" : "8a093866-6b39-4bcc-9339-18b52a02686c"
  }, {
    "source" : "c9c1ca53-f895-46c5-b394-35f22cc12ef2",
    "output" : "a038d161-3d40-4bc8-8f75-9e6154cb038c",
    "target" : "231202f3-ca0d-47a3-bf29-901d9740feb6",
    "input" : "67d3853e-3590-43a2-b968-93d2c37bc141"
  }, {
    "source" : "04400b23-bd4e-470e-95a1-f8e9d687e31e",
    "output" : "03ce7338-43a1-43f2-9442-0589b681c41a",
    "target" : "b4bde488-fce9-483a-a8be-170f7f1c6b02",
    "input" : "d0c5e8dc-7b35-45d2-ac26-903a35c45e80"
  }, {
    "source" : "04400b23-bd4e-470e-95a1-f8e9d687e31e",
    "output" : "03ce7338-43a1-43f2-9442-0589b681c41a",
    "target" : "c7c9f374-19e2-407d-880a-1eec31dda65e",
    "input" : "300cc95b-08c1-451e-b19c-e3488d552ad2"
  }, {
    "source" : "5c5060fa-2a96-44df-8169-db5ab01c7b5b",
    "output" : "43472a82-8255-4f49-bd1a-cab546e155ad",
    "target" : "c93d9226-5123-4554-ac68-3e3d867a317e",
    "input" : "53fb480f-9934-41a8-af2c-7d499b3b763e"
  }, {
    "source" : "5c5060fa-2a96-44df-8169-db5ab01c7b5b",
    "output" : "43472a82-8255-4f49-bd1a-cab546e155ad",
    "target" : "c93d9226-5123-4554-ac68-3e3d867a317e",
    "input" : "4bad2812-dc1c-4fe2-9adb-f3c038c0165e"
  }, {
    "source" : "c638b003-5fbd-43a3-a173-3f93765662ab",
    "output" : "0a29e797-8904-4aff-8de6-d7a098878f76",
    "target" : "38aa19f5-640e-4d2d-a746-ca6d43b6c1ba",
    "input" : "66d98cc4-ecef-4d62-8000-4f73edcabca8"
  }, {
    "source" : "c638b003-5fbd-43a3-a173-3f93765662ab",
    "output" : "0a29e797-8904-4aff-8de6-d7a098878f76",
    "target" : "38aa19f5-640e-4d2d-a746-ca6d43b6c1ba",
    "input" : "6e7d4d57-79ea-48ee-a0d7-98f43b2a8c36"
  }, {
    "source" : "c638b003-5fbd-43a3-a173-3f93765662ab",
    "output" : "e5a5aafd-4a71-41d1-a468-7f9d5bc8c63d",
    "target" : "62b6f5ef-5486-4397-b8b9-6cbff6a4c2d1",
    "input" : "25930615-a513-4590-ae7d-1e823aad0a93"
  }, {
    "source" : "38aa19f5-640e-4d2d-a746-ca6d43b6c1ba",
    "output" : "bf4b1995-d556-4a45-b1e1-f6b32aadadc7",
    "target" : "5c5060fa-2a96-44df-8169-db5ab01c7b5b",
    "input" : "ee3056d2-2bbb-4a8f-bed3-56262bb2c3ad"
  }, {
    "source" : "62b6f5ef-5486-4397-b8b9-6cbff6a4c2d1",
    "output" : "47102bcb-e903-4273-92ba-dfed0b87c45d",
    "target" : "d3d85dec-8138-45ff-bf7d-66c96333e43b",
    "input" : "bc7d72a1-8862-4fc4-91ff-c2d3e3850370"
  }, {
    "source" : "c93d9226-5123-4554-ac68-3e3d867a317e",
    "output" : "1c8b8f11-2625-45ef-8400-5442e7af9ca9",
    "target" : "62b6f5ef-5486-4397-b8b9-6cbff6a4c2d1",
    "input" : "52811f7e-a499-4e8e-996d-fb7ce9f92d9f"
  }, {
    "source" : "b4bde488-fce9-483a-a8be-170f7f1c6b02",
    "output" : "86bbaf87-5f9a-4744-8ec3-0c7419f73c1b",
    "target" : "2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58",
    "input" : "a1b4222c-81b2-4cd2-8efc-28d493c2d955"
  }, {
    "source" : "b4bde488-fce9-483a-a8be-170f7f1c6b02",
    "output" : "bea7ebb5-ae8c-4106-a710-23af77573689",
    "target" : "2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58",
    "input" : "d24be319-8ad8-4e15-ad7f-c9795e374078"
  }, {
    "source" : "42f5c52c-91c3-4601-97e5-e1d39b4da0b1",
    "output" : "707242c3-ff12-4b26-9d20-cd7ec7b2a1f7",
    "target" : "46c93cbd-ea5e-4626-9a00-c5a7804d49fd",
    "input" : "0c3700f8-bf40-4856-83c7-6ffbff83d815"
  }, {
    "source" : "42f5c52c-91c3-4601-97e5-e1d39b4da0b1",
    "output" : "707242c3-ff12-4b26-9d20-cd7ec7b2a1f7",
    "target" : "46c93cbd-ea5e-4626-9a00-c5a7804d49fd",
    "input" : "da3fdf3c-566e-4262-8feb-960e376d9151"
  }, {
    "source" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "output" : "6e0499de-4bf9-4adc-be4c-f85a9aa38dff",
    "target" : "9cc8d2a6-60c1-476e-8980-dc1f9358d6f3",
    "input" : "d7f55193-7a1c-408c-847d-513a69c764e6"
  }, {
    "source" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "output" : "6e0499de-4bf9-4adc-be4c-f85a9aa38dff",
    "target" : "9cc8d2a6-60c1-476e-8980-dc1f9358d6f3",
    "input" : "2c9c2f75-b55c-4636-93f4-95db8f372ed1"
  }, {
    "source" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "output" : "4e06f56d-50df-4636-955b-4baab14937d6",
    "target" : "4b8cd9a7-e7ba-43ac-82c8-62f79ab40d9d",
    "input" : "a43d88df-f644-492b-b04f-e2443ac0d317"
  }, {
    "source" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "output" : "12a3e2f4-e9d9-4d51-93ca-92b6b22d47eb",
    "target" : "3a1a149a-6f20-45b7-a1e7-3805de0418b7",
    "input" : "9827f8f4-7233-4b47-b4fb-f7b91c429459"
  }, {
    "source" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "output" : "12a3e2f4-e9d9-4d51-93ca-92b6b22d47eb",
    "target" : "e097238b-03d2-447e-9a6c-b5bbf9bf8c1f",
    "input" : "46547060-f6d7-4d01-87c7-75038e8c939a"
  }, {
    "source" : "9cc8d2a6-60c1-476e-8980-dc1f9358d6f3",
    "output" : "95ac9085-276d-4a08-8dc5-d676d121832e",
    "target" : "42f5c52c-91c3-4601-97e5-e1d39b4da0b1",
    "input" : "74ac1511-570e-4ee1-816f-fd0888aa056a"
  }, {
    "source" : "3a1a149a-6f20-45b7-a1e7-3805de0418b7",
    "output" : "ea9506ab-e323-4662-bebe-66b942df17e4",
    "target" : "5bab2336-4846-4328-9c79-845c7114df60",
    "input" : "f50bee6d-0b14-4108-b1ca-bfc3cbe8b9ad"
  }, {
    "source" : "3a1a149a-6f20-45b7-a1e7-3805de0418b7",
    "output" : "57bf2b55-1470-4ce3-be34-f906124822aa",
    "target" : "5bab2336-4846-4328-9c79-845c7114df60",
    "input" : "c0de3f88-ae2d-4b43-8acc-c0dc1418b45a"
  }, {
    "source" : "c2e8f749-63da-44d7-a744-a2434e831e92",
    "output" : "5bb197a2-e16b-4167-bbd8-c07c0cdb0ea9",
    "target" : "3a1a149a-6f20-45b7-a1e7-3805de0418b7",
    "input" : "a08daef0-c41b-4872-b963-5a2c85d6d74f"
  }, {
    "source" : "f19e4168-a6ff-400f-ac92-89a482fc1622",
    "output" : "670714c6-9b7a-4f44-8761-0628189cf3ee",
    "target" : "cc76cbe6-e332-4f55-aed3-45cb5e7f979c",
    "input" : "dd0c8249-6f2d-4b86-9555-dacf6ed10543"
  }, {
    "source" : "e097238b-03d2-447e-9a6c-b5bbf9bf8c1f",
    "output" : "33ec7eda-2f4d-4def-be57-42b5df22b6ca",
    "target" : "4b8cd9a7-e7ba-43ac-82c8-62f79ab40d9d",
    "input" : "71af32ea-f46b-4172-b96e-2d1e8a9ec7db"
  }, {
    "source" : "4b8cd9a7-e7ba-43ac-82c8-62f79ab40d9d",
    "output" : "4aa3c4ec-5102-409b-8b38-5fb1ef11f41a",
    "target" : "c2e8f749-63da-44d7-a744-a2434e831e92",
    "input" : "779484ed-932f-4d3b-942f-cad5a5d3dcc5"
  }, {
    "source" : "46c93cbd-ea5e-4626-9a00-c5a7804d49fd",
    "output" : "09da53a0-25e4-42f3-bc38-bcab64037093",
    "target" : "e097238b-03d2-447e-9a6c-b5bbf9bf8c1f",
    "input" : "2a7dae62-2540-444a-91d4-ee56c341629b"
  }, {
    "source" : "5bab2336-4846-4328-9c79-845c7114df60",
    "output" : "5951f1db-f23a-47c5-a6e3-a933bd8d4a7c",
    "target" : "513fec3e-5bdf-4cb7-aff4-c908908ed612",
    "input" : "eaa9ff16-ae3f-45e8-a484-7ba45b3a548e"
  }, {
    "source" : "5bab2336-4846-4328-9c79-845c7114df60",
    "output" : "5951f1db-f23a-47c5-a6e3-a933bd8d4a7c",
    "target" : "513fec3e-5bdf-4cb7-aff4-c908908ed612",
    "input" : "7bd82625-8d09-4909-a0bf-19dbfb064f84"
  }, {
    "source" : "5bab2336-4846-4328-9c79-845c7114df60",
    "output" : "8d6c836b-4d83-41d7-b265-1425b9346362",
    "target" : "f19e4168-a6ff-400f-ac92-89a482fc1622",
    "input" : "a7210084-884b-47ca-a86b-be9bd834f6ea"
  }, {
    "source" : "2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58",
    "output" : "44e0541a-dfc7-4900-b09e-2c9c953b8d9f",
    "target" : "f19e4168-a6ff-400f-ac92-89a482fc1622",
    "input" : "729bbb76-e7cb-40d6-81a7-0afa331b0a07"
  }, {
    "source" : "2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58",
    "output" : "cedd32c1-ea85-4e23-9a1e-9c6b5f327a24",
    "target" : "c2e8f749-63da-44d7-a744-a2434e831e92",
    "input" : "825b748e-e690-4612-a9f7-85230f6c5784"
  }, {
    "source" : "c7c9f374-19e2-407d-880a-1eec31dda65e",
    "output" : "6600cb33-7c23-41e8-a204-4b94b2a2cb53",
    "target" : "49724794-3d9a-42c8-b68f-61f446a85ae5",
    "input" : "c485256b-f039-40ec-9e8a-cbc4da8475d9"
  }, {
    "source" : "c7c9f374-19e2-407d-880a-1eec31dda65e",
    "output" : "72e739d7-5a6c-4281-95db-ea38caae768a",
    "target" : "49724794-3d9a-42c8-b68f-61f446a85ae5",
    "input" : "1793f188-7078-4576-b11e-ebff13489f4a"
  }, {
    "source" : "0459299e-2c7d-4502-a36b-4e4d15ee2ced",
    "output" : "df359d33-f814-49ab-9c5d-30727b7429c3",
    "target" : "9d52ce6b-8118-4be1-bd30-c85e85d97103",
    "input" : "264027fa-a136-462e-aacc-9a3c30c0441c"
  }, {
    "source" : "0459299e-2c7d-4502-a36b-4e4d15ee2ced",
    "output" : "df359d33-f814-49ab-9c5d-30727b7429c3",
    "target" : "9d52ce6b-8118-4be1-bd30-c85e85d97103",
    "input" : "3e2ebba9-74da-46d6-9510-8c95b69b8d06"
  }, {
    "source" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "output" : "dee1e7e0-6264-4846-aaac-78591543953e",
    "target" : "e3167185-7e42-4bf2-8054-d026df653550",
    "input" : "f6061b9f-6b0c-404a-acce-00b5e3c97f00"
  }, {
    "source" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "output" : "dee1e7e0-6264-4846-aaac-78591543953e",
    "target" : "e3167185-7e42-4bf2-8054-d026df653550",
    "input" : "ac2e310d-08bf-4394-8bb1-00e4cfc75ad8"
  }, {
    "source" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "output" : "34ac6cb2-81ae-4177-886b-0b507dfa354d",
    "target" : "c1b2486c-83d8-43d3-a809-3a592d7a7940",
    "input" : "eb593e79-8ca5-48ef-9553-2b22ffbc558d"
  }, {
    "source" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "output" : "6f9b041e-2c56-4f93-8937-0b8f54c64b90",
    "target" : "377a00f7-a686-490d-b8d0-81ba775ecf7b",
    "input" : "4e25f6f8-8c1c-49c1-9257-5ecd36bb36e6"
  }, {
    "source" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "output" : "6f9b041e-2c56-4f93-8937-0b8f54c64b90",
    "target" : "21d6fbc2-88d5-4a39-8ca8-f8fcf7134898",
    "input" : "4b00b62f-6a2d-4f7d-8f96-0a0432cde4d1"
  }, {
    "source" : "e3167185-7e42-4bf2-8054-d026df653550",
    "output" : "3aa3ee08-fa64-4d47-a1f9-f24fe019de67",
    "target" : "0459299e-2c7d-4502-a36b-4e4d15ee2ced",
    "input" : "b60c39b3-859e-4a44-bd61-f04b9256256e"
  }, {
    "source" : "377a00f7-a686-490d-b8d0-81ba775ecf7b",
    "output" : "0fdaf92d-1b98-4f88-87e9-70378281e2fa",
    "target" : "d9d6800f-d391-4a85-8320-34e956108685",
    "input" : "73c4244d-4b1d-4c31-85da-2c5822efbdbb"
  }, {
    "source" : "377a00f7-a686-490d-b8d0-81ba775ecf7b",
    "output" : "0996c8bd-4518-46d2-acc5-0f0f9c0a1341",
    "target" : "d9d6800f-d391-4a85-8320-34e956108685",
    "input" : "a40ca88a-24b8-4bdc-9b38-644a09f67919"
  }, {
    "source" : "7fb271d6-911a-4606-993e-84551298e8bc",
    "output" : "6f003384-016e-4e3e-b453-1fc1a59314d1",
    "target" : "377a00f7-a686-490d-b8d0-81ba775ecf7b",
    "input" : "16b8c63a-5a5c-4c12-b3ab-e35bbfb33c3c"
  }, {
    "source" : "2de3f637-ae8f-42c3-8aef-9e8abce7b0f5",
    "output" : "90484345-9597-4f2b-b87b-2837d9ea0ead",
    "target" : "c5214ec8-688e-4af4-9760-90f7baab8340",
    "input" : "407e2f9f-91c5-4dff-a220-d057ef0b650c"
  }, {
    "source" : "21d6fbc2-88d5-4a39-8ca8-f8fcf7134898",
    "output" : "f5c37798-5ad5-45c8-9e41-f555d7a2f963",
    "target" : "c1b2486c-83d8-43d3-a809-3a592d7a7940",
    "input" : "6a38a0c6-a176-4cac-9ff8-0d3e5b129e0a"
  }, {
    "source" : "c1b2486c-83d8-43d3-a809-3a592d7a7940",
    "output" : "4e86b1f3-ffbe-4aa9-8876-67023c05024d",
    "target" : "7fb271d6-911a-4606-993e-84551298e8bc",
    "input" : "a7e63361-e808-4150-899c-85bc8f64d009"
  }, {
    "source" : "9d52ce6b-8118-4be1-bd30-c85e85d97103",
    "output" : "46901066-9195-4b64-bab0-2e60616a2a72",
    "target" : "21d6fbc2-88d5-4a39-8ca8-f8fcf7134898",
    "input" : "203ebcb0-e4ea-46cf-80bd-1da5ef8629db"
  }, {
    "source" : "d9d6800f-d391-4a85-8320-34e956108685",
    "output" : "408ebf20-5c43-4489-bb18-97551b48b755",
    "target" : "217b6ae0-de43-458e-a356-883a583118e9",
    "input" : "a483327b-86dd-4aee-80d9-b9dab51623ba"
  }, {
    "source" : "d9d6800f-d391-4a85-8320-34e956108685",
    "output" : "f81efa93-1be4-4e04-96b8-eb33e4d986e5",
    "target" : "2de3f637-ae8f-42c3-8aef-9e8abce7b0f5",
    "input" : "d2f0f42b-52ea-42fd-a52c-81aff5464e29"
  }, {
    "source" : "49724794-3d9a-42c8-b68f-61f446a85ae5",
    "output" : "395b2cf3-2212-4641-aec8-c5839c0c4cee",
    "target" : "2de3f637-ae8f-42c3-8aef-9e8abce7b0f5",
    "input" : "06cb71c1-342b-40e3-bd55-5fe0ee79d418"
  }, {
    "source" : "49724794-3d9a-42c8-b68f-61f446a85ae5",
    "output" : "eb31703e-4216-4a2b-a7d3-640c4492d7ec",
    "target" : "7fb271d6-911a-4606-993e-84551298e8bc",
    "input" : "80607db7-560a-4b03-970f-378d4fe1621f"
  } ],
  "bendpoints" : "[{\"source\":\"49724794-3d9a-42c8-b68f-61f446a85ae5\",\"target\":\"7fb271d6-911a-4606-993e-84551298e8bc\",\"coordinates\":\"1315:530\"},{\"source\":\"c5214ec8-688e-4af4-9760-90f7baab8340\",\"target\":\"377a00f7-a686-490d-b8d0-81ba775ecf7b\",\"coordinates\":\"1410:690\"},{\"source\":\"2b1a9298-7b6c-4fa7-8dc7-e76e0b708b58\",\"target\":\"c2e8f749-63da-44d7-a744-a2434e831e92\",\"coordinates\":\"665:100\"},{\"source\":\"c5214ec8-688e-4af4-9760-90f7baab8340\",\"target\":\"21d6fbc2-88d5-4a39-8ca8-f8fcf7134898\",\"coordinates\":\"1110:690\"},{\"source\":\"6e3f1bdb-21e3-4a7f-a5af-33f3514b23a8\",\"target\":\"231202f3-ca0d-47a3-bf29-901d9740feb6\",\"coordinates\":\"1760:1120\"},{\"source\":\"c638b003-5fbd-43a3-a173-3f93765662ab\",\"target\":\"62b6f5ef-5486-4397-b8b9-6cbff6a4c2d1\",\"coordinates\":\"2160:1300\"},{\"source\":\"5bab2336-4846-4328-9c79-845c7114df60\",\"target\":\"513fec3e-5bdf-4cb7-aff4-c908908ed612\",\"coordinates\":\"1690:350\"},{\"source\":\"cc76cbe6-e332-4f55-aed3-45cb5e7f979c\",\"target\":\"e097238b-03d2-447e-9a6c-b5bbf9bf8c1f\",\"coordinates\":\"460:260\"},{\"source\":\"04400b23-bd4e-470e-95a1-f8e9d687e31e\",\"target\":\"c7c9f374-19e2-407d-880a-1eec31dda65e\",\"coordinates\":\"937:-9\"},{\"source\":\"cc76cbe6-e332-4f55-aed3-45cb5e7f979c\",\"target\":\"3a1a149a-6f20-45b7-a1e7-3805de0418b7\",\"coordinates\":\"760:260\"},{\"source\":\"d9d6800f-d391-4a85-8320-34e956108685\",\"target\":\"2de3f637-ae8f-42c3-8aef-9e8abce7b0f5\",\"coordinates\":\"1500:600\"},{\"source\":\"5bab2336-4846-4328-9c79-845c7114df60\",\"target\":\"f19e4168-a6ff-400f-ac92-89a482fc1622\",\"coordinates\":\"850:170\"},{\"source\":\"231202f3-ca0d-47a3-bf29-901d9740feb6\",\"target\":\"c638b003-5fbd-43a3-a173-3f93765662ab\",\"coordinates\":\"2090:1210\"},{\"source\":\"c5214ec8-688e-4af4-9760-90f7baab8340\",\"target\":\"c1b2486c-83d8-43d3-a809-3a592d7a7940\",\"coordinates\":\"1225:690\"},{\"source\":\"04400b23-bd4e-470e-95a1-f8e9d687e31e\",\"target\":\"b4bde488-fce9-483a-a8be-170f7f1c6b02\",\"coordinates\":\"293:-8\"},{\"source\":\"cc76cbe6-e332-4f55-aed3-45cb5e7f979c\",\"target\":\"4b8cd9a7-e7ba-43ac-82c8-62f79ab40d9d\",\"coordinates\":\"575:260\"}]"
}